package main

import (
	"fmt"
	"net"
	"sync"
	"time"
)

func scanPorts(ip string) {
	var begin = time.Now()
	// 初始化一个sync.WaitGroup，用于等待所有goroutines完成
	var wg sync.WaitGroup
	for j := 1; j <= 65535; j++ {
		// 每次循环时将这个语句等待计数加1，表示有一个goroutines需要等待完成
		wg.Add(1)

		//go 关键字用于启动一个新的goroutine，为了在扫描端口时会有独立的goroutine执行
		go func(i int) {
			//defer：用于延迟函数的执行，确保在函数退出时执行wg.Done()
			//wg.Done()会将等待计数减1，表示一个goroutine已经完成
			defer wg.Done()

			var address = fmt.Sprintf("%s:%d", ip, i)
			conn, err := net.Dial("tcp", address)
			if err != nil {

				return
			}
			conn.Close()
			fmt.Println(address, "is open")
		}(j)
	}

	//也就是说在每个端口扫描任务启动时，增加等待计数，然后在每个任务结束时减少等待计数。通过 wg.Wait() 主动等待所有goroutines完成，确保在主程序继续执行之前，所有端口扫描任务都已经完成
	wg.Wait()

	var elapsedTime = time.Now().Sub(begin)
	fmt.Println("Time elapsed:", elapsedTime)
}

func main() {

	var ip string
	fmt.Print("Enter the IP address to scan: ")
	fmt.Scanln(&ip)

	scanPorts(ip)
}
